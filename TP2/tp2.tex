\documentclass[a4paper,10pt]{article}
\usepackage[paper=a4paper, hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}


\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}

\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripción:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representación}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Titulo}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}

\section{Módulo Ciudad Robotica}


\begin{Interfaz}


  \textbf{se explica con}: \tadNombre{Secuencia$(\alpha)$}, \tadNombre{Iterador Bidireccional($\alpha$)}.

  \textbf{géneros}: \TipoVariable{ciudad}, \TipoVariable{itLista($\alpha$)}.

  \textbf{usa}: 
  
  \Titulo{Operaciones básicas de ciudad}

  \InterfazFuncion{Crear}{\In{m}{mapa}}{ciudad}%
  {$res \igobs$ crear($m$)}%
  [$\Theta(1)$]
  [genera una nueva Ciudad.]
  [lo ideal seria no copiar ese mapa no?]
  
  \InterfazFuncion{Entrar}{\In{ts}{conj(tag)}, \In{e}{estacion}, \Inout{c}{ciudad}}{}
  [$c \igobs c_0 \land e \in$ estaciones($c$)]
  {$c \igobs$ entrar($ts, e, c_0$)}
  [$\Theta(copy(a))$]
  [...]
  [...]

  \InterfazFuncion{Mover}{\In{u}{rur}, \In{e}{estacion}, \Inout{c}{ciudad}}{}
  [$c \igobs c_0 \land e \in$ estaciones($c$)$\land \in $ robots($c$)]
  {$c \igobs$ mover($u, e, c_0$)}
  [$\Theta(copy(a))$]
  [...]
  [...]
  
  \InterfazFuncion{Inspeccion}{\In{e}{estacion}, \Inout{c}{ciudad}}{}
  [$c \igobs c_0 \land e \in$ estaciones($c$)]
  {$c \igobs$ inspeccion($e, c_0$)}
  [$\Theta(copy(a))$]
  [...]
  [...]
 
 \InterfazFuncion{ProximoRUR}{\In{c}{ciudad}}{rur}
  {$res \igobs$ proximoRUR($c$)}
  [$O(1)$]
  [...]
  [...]
  
  \InterfazFuncion{Mapa}{\In{c}{ciudad}}{mapa}
  {$res \igobs$ mapa($c$)}
  [$\Theta(copy(a))$]
  [...]
  [...]
  
  \InterfazFuncion{Robots}{\In{c}{ciudad}}{it(conj(rur))}
  {$res \igobs$ CrearIt(robots($c$))}
  [$O(1)$]
  [...]
  [...]
  
  \InterfazFuncion{Estacion}{\In{u}{rur}, \In{c}{ciudad}}{estacion}
  [$u \in$  robots($c$)]
  {$res \igobs$ estacion($u, c$)}
  [$O(1)$]
  [...]
  [...]
  
  \InterfazFuncion{Tags}{\In{u}{rur}, \In{c}{ciudad}}{conj(tag)}
  [$u \in$ robots($c$)]
  {$c \igobs$ inspeccion($e, c_0$)}
  [$O(1)$]
  [...]
  [...]

  \InterfazFuncion{$\#$Infracciones}{\In{u}{rur}, \In{c}{ciudad}}{nat}
  [$u \in$ robots($c$)]
  {$c \igobs$ inspeccion($e, c_0$)}
  [$\Theta(copy(a))$]
  [...]
  [...]

  \InterfazFuncion{Estaciones}{\In{c}{ciudad}}{it(conj(estaciones))}
  {$res \igobs$ CrearIt(estaciones($c$))} %CrearIt es la del modulo conjunto
  [$O(1)$]
  [...]
  [...]
  
\end{Interfaz}

\begin{Representacion}
  
  \Titulo{Representación de la ciudad}

  \begin{Estructura}{ciudad}[str]
    \begin{Tupla}[str]
      \tupItem{robRUR}{DiccArreglo(rur, puntero(datosRobot))}%
      \tupItem{\\robEstacion}{DiccTrie(estacion, colaPrio(rur))}%
      \tupItem{\\mapa}{vector(senda)}%
    \end{Tupla}

    \begin{Tupla}[senda]
	 \tupItem{est1}{estacion}
	 \tupItem{est2}{estacion}
	 \tupItem{restr}{restriccion}   
    \end{Tupla}
    
    \begin{Tupla}[datosRobot]
      \tupItem{presente?}{bool}%
      \tupItem{\\est}{estacion}%
      \tupItem{\\infr}{nat}%
      \tupItem{\\tags}{conjTrie(tags)}%
      \tupItem{\\permisos}{DiccTrie(estacion, DiccTrie(estacion, bool)}%
      \tupItem{\\itEst}{it(colaPrio(rur))}%
    \end{Tupla}
   
    
  \end{Estructura}

  \Rep[lst][l]{($l$.primero $=$ NULL) $=$ ($l$.longitud $=$ $0$) $\yluego$ ($l$.longitud $\neq$ $0$ \impluego \\
    Nodo($l$, $l$.longitud) $=$ $l$.primero $\land$ \\
    ($\forall i$: nat)(Nodo($l$,$i$)\DRef siguiente $=$ Nodo($l$,$i+1$)\DRef anterior) $\land$ \\
    ($\forall i$: nat)($1 \leq i <$ $l$.longitud $\implies$ Nodo($l$,$i$) $\neq$ $l$.primero)}\mbox{}

  ~      

  \tadOperacion{Nodo}{lst/l,nat}{puntero(nodo)}{$l$.primero $\neq$ NULL}
  \tadAxioma{Nodo($l$,$i$)}{\IF $i = 0$ THEN $l$.primero ELSE Nodo(FinLst($l$), $i-1$) FI}

  ~

  \tadOperacion{FinLst}{lst}{lst}{}
  \tadAxioma{FinLst($l$)}{Lst($l$.primero\DRef siguiente, $l$.longitud $-$ $\min$\{$l$.longitud, $1$\})}

  ~

  \tadOperacion{Lst}{puntero(nodo),nat}{lst}{}
  \tadAxioma{Lst($p,n$)}{$\langle p, n\rangle$}

  ~
 
  \AbsFc[lst]{secu($\alpha$)}[l]{\IF $l$.longitud $=$ $0$ THEN \secuencia{} ELSE \secuencia{$l$.primero\DRef dato}[Abs(FinLst($l$))] FI}

  \Titulo{Representación del iterador}

  \begin{Estructura}{itLista($\alpha$)}[iter]
    \begin{Tupla}[iter]
      \tupItem{siguiente}{puntero(nodo)}%
      \tupItem{lista}{puntero(lst)}%
    \end{Tupla}
  \end{Estructura}

  \Rep[iter][it]{Rep($\ast$($it$.lista)) $\yluego$ ($it$.siguiente $=$ NULL $\oluego$ ($\exists i$: nat)(Nodo($\ast it$.lista, $i$) $=$ $it$.siguiente)}

  ~

  \Abs[iter]{itBi($\alpha$)}[it]{b}{Siguientes($b$) $=$ Abs(Sig($it$.lista, $it$.siguiente)) $\land$\\
    Anteriores($b$) $=$ Abs(Ant($it$.lista, $it$.siguiente))}

  ~

  \tadOperacion{Sig}{puntero(lst)/l,puntero(nodo)/p}{lst}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Sig($i, p$)}{Lst($p$, $l$\DRef longitud $-$ Pos($\ast l$, $p$))}

  ~

  \tadOperacion{Ant}{puntero(lst)/l,puntero(nodo)/p}{lst}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Ant($i, p$)}{Lst(\IF $p$ $=$ $l$\DRef primero THEN NULL ELSE $l$\DRef primero FI, Pos($\ast l$, $p$))}

  ~

  {\small Nota: cuando $p$ $=$ NULL, Pos devuelve la longitud de la lista, lo cual está bien, porque significa que el iterador no tiene siguiente.}
  \tadOperacion{Pos}{lst/l,puntero(nodo)/p}{puntero(nodo)}{Rep($\langle l, p\rangle$)}
  \tadAxioma{Pos($l$,$p$)}{\IF $l$.primero $=$ $p$ $\lor$ $l$.longitud $=$ $0$ THEN $0$ ELSE $1$ $+$ Pos(FinLst($l$), $p$) FI}


\end{Representacion}

\begin{Algoritmos}
 
 
\end{Algoritmos}

\section{Modulo Cola de Prioridad}

\begin{Interfaz}
  \textbf{se explica con}: \tadNombre{Cola de prioridad($\alpha$)}

  \textbf{géneros}: \TipoVariable{colaPrio($\alpha$)}

  \textbf{usa}: 

  \InterfazFuncion{Vacia}{}{colaPrio($\alpha$)}%
  {$res \igobs$ vacia}%
  [$\Theta(1)$]
  [genera una cola vacia.]
  
  \InterfazFuncion{Encolar}{\In{a}{$\alpha$}, \In{n}{nat},\Inout{c}{colaPrio($\alpha$)}}{}%
  [$c \igobs c_0$]
  {$res \igobs$ encolar(a, c)}%
  [$\Theta(1)$]
  [agrega a la cola el elemento $a$]
  [$a$ se agrega por copia]
  
    
  \InterfazFuncion{Vacia?}{\In{c}{colaPrio($\alpha$)}}{bool}%
  {$res \igobs$ vacia?(c)}%
  [$\Theta(1)$]
  [checkea si la cola esta vacia]
  
  \InterfazFuncion{Desencolar}{\Inout{c}{colaPrio($\alpha$)}}{$\alpha$}%
  [$c \igobs c_0 \land \neg$ vacia?($c_0$)]%
  {}
  [$O(log n)$]
  [elimina el proximo de la cola y retorna el elemento]
  []  
  
    \Titulo{Operaciones del iterador}
El iterador es necesario para eliminar en el mover
  
\end{Interfaz}

\begin{Representacion}
\Titulo{Representacion de la cola}
\begin{Estructura}{colaPrio($\alpha$)}[c]
  \begin{Tupla}[c]
   \tupItem{raiz}{puntero(Nodo)}
   \tupItem{padreUlt}{puntero(Nodo)}
   \tupItem{cant}{nat}
  \end{Tupla}
  
  \begin{Tupla}[Nodo]
   \tupItem{prioridad}{nat}
   \tupItem{\\elem}{$\alpha$}   
   \tupItem{\\padre}{puntero(Nodo)}
   \tupItem{\\izq}{puntero(Nodo)}
   \tupItem{\\der}{puntero(Nodo)}
  \end{Tupla}


\end{Estructura}

\end{Representacion}
\begin{Algoritmos}\\
\TipoFuncion{iVacia}{}{colaPrio($\alpha$)}\\
\indent res.raiz $\leftarrow$ NULL\\
\indent res.cant $\leftarrow$ 0\\
\indent res.padreUlt $\leftarrow$ NULL\\
\\
\TipoFuncion{iEncolar}{\Inout{c}{colaPrio($\alpha$)}, \In{a}{$\alpha$}, \In{n}{nat}}{}\\
\indent c.cant++ \\
\indent var n $\leftarrow$ New Nodo\\
\indent n.prioridad $\leftarrow$ n\\
\indent n.elem $\leftarrow$ a\\
\indent if c.raiz = NULL \{ c.raiz $\leftarrow$ \& n\} \\
\indent else \{\\ 
\indent \indent if c.padreUlt $==$ NULL\{\\
\indent \indent c.padreUlt $\leftarrow$ c.raiz\\ 
\indent \indent n.padre $\leftarrow$ c.raiz\\
\indent \indent c.raiz$\rightarrow$izq $\leftarrow$ \& n \\
\indent \indent \} else \{\\
\indent \indent \indent if c.padreUlt$\rightarrow$der $==$ NULL\{\\
\indent \indent \indent \indent n.padre $\leftarrow$ c.padreUlt\\
\indent \indent \indent \indent c.padreUlt$\rightarrow$der $\leftarrow$ \& n\\
\indent \indent \indent \}else\{ \\
\indent \indent \indent \indent if $log_2(cant) == int(log_2(cant))$ \{\\
\indent \indent \indent \indent \indent c.padreUlt $\leftarrow$ busqIzq(c)\\
\indent \indent \indent \indent \indent n.padre $\leftarrow$ c.padreUlt\\
\indent \indent \indent \indent \indent c.padreUlt$\rightarrow$izq $\leftarrow$ \& n\\
\indent \indent \indent \indent \}else\{\\
\indent \indent \indent \indent \indent c.padreUlt $\leftarrow$ busqTransversal(c.padreUlt, c)\\
\indent \indent \indent \indent \indent n.padre $\leftarrow$ c.padreUlt\\
\indent \indent \indent \indent \indent c.padreUlt$\rightarrow$izq $\leftarrow$ \& n\\
\indent \indent \indent \indent \}\\
\indent \indent \indent \}\\
\indent \indent \}\\
\indent \}\\
\indent var parent$\leftarrow$ n.padre\\
\indent var aux\\
\indent while(parent != NULL $\land$ n.prioridad > parent$\rightarrow$prioridad)\{\\
\indent \indent if parent$\rightarrow$der == n\{\\
\indent \indent \indent n.padre $\leftarrow$ parent$\rightarrow$padre\\
\indent \indent \indent aux $\leftarrow$ parent$\rightarrow$izq\\
\indent \indent \indent parent$\rightarrow$der $\leftarrow$ n.der\\
\indent \indent \indent parent$\rightarrow$izq $\leftarrow$ n.izq\\
\indent \indent \indent n.der $\leftarrow$ parent\\
\indent \indent \indent n.izq $\leftarrow$ aux\\
\indent \indent \indent parent$\rightarrow$padre $\leftarrow$ \& n\\
\indent \indent \} else \{\\
\indent \indent \indent n.padre $\leftarrow$ parent$\rightarrow$padre\\
\indent \indent \indent aux $\leftarrow$ parent$\rightarrow$der\\
\indent \indent \indent parent$\rightarrow$der $\leftarrow$ n.der\\
\indent \indent \indent parent$\rightarrow$izq $\leftarrow$ n.izq\\
\indent \indent \indent n.izq $\leftarrow$ parent\\
\indent \indent \indent n.der $\leftarrow$ aux\\
\indent \indent \indent parent$\rightarrow$padre $\leftarrow$ \& n\\
\indent \indent \}\\
\indent \}\\
\indent res $\leftarrow$ crearIt(\& n)\\
\\
\TipoFuncion{ibusqIzq}{\In{c}{colaPrio($\alpha$)}}{Nodo}\\
\indent var actual $\leftarrow$ c.raiz\\
\indent while(actual$\rightarrow$izq != NULL)\{\\
\indent \indent actual $\leftarrow$ actual$\rightarrow$izq\\
\indent \}\\
\indent res $\leftarrow$ actual\\
\\
\TipoFuncion{ibusqTransversal}{\In{c}{colaPrio($\alpha$)}, \In{n}{Nodo}}{Nodo}\\
\indent var parent $\leftarrow$ n.padre\\
\indent var act $\leftarrow$ n\\
\indent while(parent$\rightarrow$der == act)\{\\
\indent \indent act $\leftarrow$ parent\\
\indent \indent parent $\leftarrow$ parent$\rightarrow$padre\\
\indent \}\\
\indent act $\leftarrow$ parent$\rightarrow$der\\
\indent while(act$\rightarrow$izq =! NULL)\{\\
\indent \indent act $\leftarrow$ act$\rightarrow$izq\\
\indent \}\\
\indent res $\leftarrow$ act\\
\\
\TipoFuncion{iVacia?}{\In{c}{colaPrio($\alpha$)}}{bool}\\
\indent res $\leftarrow$ c.cant $==$ 0\\
\\
\TipoFuncion{iDesencolar}{\Inout{c}{colaPrio($\alpha$)}}{}\\
\indent var ult\\
\indent if c.padreUlt$\rightarrow$der != NULL \{\\
\indent \indent ult $\leftarrow$ c.padreUlt$\rightarrow$der\\
\indent \indent c.padreUlt$\rightarrow$der $\leftarrow$ NULL\\
\indent \}else \{\\
\indent \indent ult $\leftarrow$ c.padreUlt$\rightarrow$izq\\
\indent \indent c.padreUlt$\rightarrow$izq $\leftarrow$ NULL\\
\indent \}\\
\indent ult$\rightarrow$padre $\leftarrow$ NULL\\
\indent ult$\rightarrow$izq $\leftarrow$ c.raiz$\rightarrow$izq\\
\indent ult$\rightarrow$der $\leftarrow$ c.raiz$\rightarrow$der\\
\indent ult$\rightarrow$der$\rightarrow$padre $\leftarrow$ ult\\
\indent ult$\rightarrow$izq$\rightarrow$padre $\leftarrow$ ult\\
\indent delete c.raiz\\
\indent c.raiz $\leftarrow$ ult\\
\indent bajar

\end{Algoritmos}

\section{Modulo DiccArreglo(nat, significado)}

\begin{Interfaz}
  \textbf{parámetros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{géneros}} nat, significado\\
  
  \textbf{se explica con}: \tadNombre{dicc($clave, significado$)}, \tadNombre{Iterador Unidireccional($\alpha$)}.\\
  \indent\textbf{géneros}: \TipoVariable{DiccArreglo(nat, significado)}, \TipoVariable{itDicc(nat)}.

  \Titulo{Operaciones básicas del diccionario arreglo}
  
  \InterfazFuncion{Vacio}{}{DiccArreglo(nat, significado)}%
  {$res \igobs$ vacio()}%
  [$\Theta(1)$]
  [genera un nuevo diccionario arreglo.]
  
  \InterfazFuncion{Definir}{\Inout{DA}{DiccArreglo(nat, significado)}, \In{s}{significado}}{}%
  [$DA_0 \igobs DA$]
  {$DA \igobs$ definir($\#claves(DA_0) + e$, s, $DA_0$)}%
  [$\Theta(n)$]
  [Define una nueva clave con su significado. Donde e es la cantidad de elementos eliminados del diccionario 	historicamente\\
   n es la cantidad de elementos en el diccionario en el estado anterior a Definir.] 

  \InterfazFuncion{Def?}{\In{a}{nat}, \In{DA}{DiccArreglo(nat, significado)}}{bool}%
  {$res \igobs$ def?(a, DA)}%
  [$\Theta(1)$]
  [Devuelve $True$ si el la clave está definida.]

  \InterfazFuncion{Obtener}{\In{a}{nat}, \In{DA}{DiccArreglo(nat, significado)}}{significado}%
  [Def?(a, DA)]  
  {$res \igobs$ obtener(a, DA)}%
  [$\Theta(1)$]
  [Devuelve el significado de la clave a.]
  
  \InterfazFuncion{Borrar}{\In{a}{nat}, \Inout{DA}{DiccArreglo(nat, significado)}}{}%
  [Def?(a, DA) $\land$ $DA_0 \igobs DA$]  
  {$DA \igobs$ borrar(a, $DA_0$)}%
  [$\Theta(1)$]
  [Borra el significado y su clave a.]
  
  \InterfazFuncion{Claves}{\Inout{DA}{DiccArreglo(nat, significado)}}{itDicc(nat)}%  
  {$res \igobs$ CrearItUni(convertir(claves($DA$)))}%
  [$\Theta(1)$]
  [Devuelve el conjunto de claves del diccionario.]
  
  \Titulo{Operaciones básicas del iterador}
  
  \InterfazFuncion{CrearIt}{\In{DA}{DiccArreglo(nat, significado)}}{itDicc(nat)}%  
  {$res$ $\leftarrow$ CrearItUni(convertir(claves($DA$)))}%
  [$\Theta(1)$]
  [Crea un iterador unidireccional del conjunto de claves \\
  de forma tal que siguiente devuelva la siguiente clave del diccionario.]
    
  \InterfazFuncion{Avanzar}{\Inout{it}{itDicc(nat)}}{}%  
  [$it = it_0$ $\land$ haySiguiente?(it)]
  {$it \igobs$ avanzar($it_0$)}%
  [$\Theta(1)$]
  [Avanza a la posición siguiente del iterador.]  
  
  \InterfazFuncion{Siguiente}{\In{it}{itDicc(nat)}}{nat}%  
  [haySiguiente?(it)]
  {$res \igobs$ siguiente($it$)}%
  [$\Theta(1)$]
  [devuelve el elemento siguiente a la posición del iterador.] 
  [res no es modificable.]  
  
  \InterfazFuncion{HaySiguiente?}{\In{it}{itDicc(nat)}}{bool}%  
  {$res \igobs$ haySiguiente($it$)}%
  [$\Theta(1)$]
  [devuelve $true$ si y solo si en el iterador quedan elementos para avanzar.] 
  [res no es modificable.]  
    
\end{Interfaz}

\begin{Representacion}

\Titulo{Representación del diccionario arreglo}
El objetivo de este modulo es implementar un arreglo de elementos que son una tupla con un significado y un booleano.
La idea es que si el booleano vale True significa que el elemento está borrado. 

 \begin{Estructura}{DiccArreglo(nat, significado)}[vec : vector(valor)]
  \begin{Tupla}[valor]
   \tupItem{sig}{significado}
   \tupItem{esta?}{bool}
  \end{Tupla}
 \end{Estructura}

  \Rep[vec][v]{true}\mbox{}\

  \AbsFc[vector(valor)]{dicc(nat, significado)}[vec]{\IF Longitud($vec$) $=$ $0$ THEN vacio ELSE 
  \textbf{if} $vec$[Longitud($vec$) $-$ 1].esta? = $true$ \textbf{then}\\ definir(Longitud($vec$) $-$ 1, $vec$[Longitud($vec$) $-$ 1].significado, AbsFc(Comienzo($vec$))) \\\textbf{else} \\
   AbsFc(Comienzo($vec$)) \\\textbf{fi} FI} 


\Titulo{Representación del iterador}
Este iterador recorre las claves que son los naturales en el rango del vector. Para esto mantiene una variable\\
actualizada con la posición siguiente. Este iterador se indefine cada vez que el vector se redefine. En ese caso debera crearse un nuevo iterador.

 \begin{Estructura}{itDicc(nat)}[itTupla]
  \begin{Tupla}[itTupla]
   \tupItem{posicion}{nat}
   \tupItem{pVec}{puntero(vector(valor))}   
  \end{Tupla}
 \end{Estructura}


 \Rep[itTupla][it]{$\neg$($it$.pVec  $=$  NULL) $\yluego$ \\ 
 ($it$.posicion $<$ Longitud(*($i$.pVec)) \&\& 0 $\leq$ $it$.posicion) $\yluego$ \\ 
 (*($it$.pVec)[$it$.posicion].esta? = true) 
 }\mbox{} \\

  \Abs[itTupla]{itUni(nat)}[it]{iu}{Siguientes($iu$) $=$ convertir(claves(Abs(*($it$.pVec)))) $\land$\\ 	
  Siguiente($iu$) $=$ $it$.posición}

\end{Representacion}

\begin{Algoritmos}

  \TipoFuncion{iVacio}{}{vector(valor)} \\
  \indent\indent res $\leftarrow$ Vacía();\\
  
  \TipoFuncion{iDefinir}{\Inout{vec}{vector(valor)}, \In{s}{significado}}{} \\
  \indent\indent\indent\indent res  $\leftarrow$ AgregarAtras(vec, s);\\
  
  \TipoFuncion{iDef?}{\In{a}{nat}, \Inout{vec}{vector(valor)}}{bool} \\
  \indent\indent res $\leftarrow$ false; \\ 
  \indent\indent if a $<$ Longitud(vec) \&\& a $>$ 0 \{ \\
  \indent\indent\indent\indent if vec[a].esta? true \{ \\ 
  \indent\indent\indent\indent\indent\indent res $\leftarrow$ true; \\
  \indent\indent\indent\indent \} \\ 
  \indent\indent\} \\

  \TipoFuncion{iObtener}{\In{a}{nat}, \Inout{vec}{vector(valor)}}{valor} \\
  \indent\indent res $\leftarrow$ vec[a].significado; \\

  \TipoFuncion{iBorrar}{\In{a}{nat}, \Inout{vec}{vector(valor)}}{} \\
  \indent\indent vec[a].esta? $\leftarrow$ false; \\ 
  
  \TipoFuncion{iClaves}{\Inout{vec}{vector(valor)}}{itDicc(nat)} \\
  \indent\indent res $\leftarrow$ iCrearIt(vec);
  
\end{Algoritmos}
\section{Modulo Restriccion}

\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{Restriccion}

  \textbf{géneros}: \TipoVariable{restriccion}

  \textbf{usa}: 


  \InterfazFuncion{NuevoTag}{\In{t}{tag}}{restriccion}%
  {$res \igobs$ <t>}%
  [$\Theta(1)$]
  [genera una restriccion de un solo tag.]

  \InterfazFuncion{Not}{\Inout{r}{restriccion}}{}% este capaz que es inout
  {$res \igobs$ NOT $r$}%
  [$\Theta(1)$]
  [...]
  [...]

  \InterfazFuncion{And}{\In{r1}{restriccion}, \In{r2}{restriccion}}{restriccion}%
  {$res \igobs$ $r1$ AND $r2$}%
  [$\Theta(1)$]
  [...]
  [...]

  \InterfazFuncion{Or}{\In{r1}{restriccion}, \In{r2}{restriccion}}{restriccion}%
  {$res \igobs$ $r1$ OR $r2$}%
  [$\Theta(1)$]
  [...]
  [...]
  
  \InterfazFuncion{Verifica?}{\In{ts}{conj(tag)}, \In{r}{restriccion}}{bool}%
  {$res \igobs$ verifica?(ts, r)}%
  [$O(R)$]
  [...]
  [...]  
  
  
\end{Interfaz}

\begin{Representacion}
 \Titulo{Representacion de la restriccion}
 
 \begin{Estructura}{restriccion}[rtr]
  \begin{Tupla}[rtr]
   \tupItem{raiz}{puntero(Nodo)}
  \end{Tupla}

  \begin{Tupla}[Nodo]
   \tupItem{tag}{tag}
   \tupItem{\\tipo}{log}
   \tupItem{\\negado?}{bool}
   \tupItem{\\izq}{puntero(Nodo)}
   \tupItem{\\der}{puntero(Nodo)}
  \end{Tupla}
  
  \indent donde log es enum\{AND, OR, CAR\}
 \end{Estructura}

\Rep[rtr][r]{completo?(r.raiz) \yluego noCiclos(r.raiz, $\emptyset$) \yluego esRestriccion?(r.raiz)}

\tadOperacion{completo?}{Nodo/n}{bool}{}
\tadAxioma{completo?(n)}{(n.izq \igobs NULL $\land$ n.der \igobs NULL) $\lor$\\
$\neg$(n.izq \igobs NULL) $\land$ $\neg$ (n.der \igobs NULL) $\land$\\
completo?(n.izq) $\land$ completo?(n.der)}

\tadOperacion{esRestriccion?}{Nodo/n}{bool}{}
\tadAxioma{esRestriccion?(n)}{if n.tipo \igobs CAR \\ 
then n.izq \igobs NULL $\land$ n.der \igobs NULL\\
else n.izq $\neq$ NULL $\land$ n.der $\neq$ NULL \yluego \\
esRestriccion?(n.izq) $\land$ esRestriccion?(n.der)\\ end if}

\Abs[rtr]{restriccion}[r]{rest}{($\forall$ ts : conj(tag)) verifica?(ts, rest) $=$ Verifica?(ts, r)}

\end{Representacion}

\begin{Algoritmos}\\
\TipoFuncion{iNuevoTag}{\In{t}{tag}}{restriccion}\\ 
 \indent puntero(Nodo) n $\leftarrow$ New Nodo\\
 \indent n.tag $\leftarrow$ t\\
 \indent n.tipo $\leftarrow$ CAR\\
 \indent n.negado $\leftarrow$ false\\
 \indent n.izq $\leftarrow$ NULL\\
 \indent n.der $\leftarrow$ NULL\\
 \indent res.raiz $\leftarrow$ n\\
\\
\TipoFuncion{iNot}{\Inout{r1}{restriccion}}{}\\  
\indent r1.negado? $\leftarrow$ true\\
\\
\TipoFuncion{iAnd}{\In{r1}{restriccion}, \In{r2}{restriccion}}{restriccion}\\
 \indent puntero(Nodo) n $\leftarrow$ New Nodo\\
 \indent n.tipo $\leftarrow$ AND\\
 \indent n.negado $\leftarrow$ false\\
 \indent n.izq $\leftarrow$ r1.raiz\\
 \indent n.der $\leftarrow$ r2.raiz\\
 \indent res.raiz $\leftarrow$ n\\
\\ 
\TipoFuncion{iOr}{\In{r1}{restriccion}, \In{r2}{restriccion}}{restriccion}\\
 \indent puntero(Nodo) n $\leftarrow$ New Nodo\\
 \indent n.tipo $\leftarrow$ OR\\
 \indent n.negado $\leftarrow$ false\\
 \indent n.izq $\leftarrow$ r1.raiz\\
 \indent n.der $\leftarrow$ r2.raiz\\
 \indent res.raiz $\leftarrow$ n\\
\\
\TipoFuncion{iVerifica? }{\In{r}{restriccion}, \In{ts}{tags}}{bool}\\
\indent res $\leftarrow$ verificaAux(r.raiz, ts)
\\
\\
\TipoFuncion{iverificaAux}{\In{n}{Nodo}, \In{ts}{tags}}{bool}\\
\indent bool aux $\leftarrow$ false\\
\indent if n.tipo = CAR \\
\indent \indent then aux $\leftarrow$ pertenece?(n.tag, ts)\\
\indent \indent else if n.tipo = AND\\
\indent \indent \indent then aux $\leftarrow$ verificaAux(n.izq, ts) $\land$ verificaAux(n.der, ts)\\ 
\indent \indent \indent else aux $\leftarrow$ verificaAux(n.izq, ts) $\lor$ verificaAux(n.der, ts)\\
\indent if n.negado? then res $\leftarrow$ $\neg$ aux\\
\indent \indent else res $\leftarrow$ aux\\

\end{Algoritmos}

\newpage

\section{Módulo Diccionario($\sigma$)}

\begin{Interfaz}
  
  \textbf{parámetros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{géneros}} $\sigma$\\
  % notar que ya existe el tad diccionario, este es otro. por ahora lo dejo asi, pero lo mejor seria darle un renombre.
  \textbf{se explica con}: \tadNombre{Diccionario($\sigma$)}.

  \textbf{géneros}: \TipoVariable{dicc($\sigma$)}.

  \Titulo{Operaciones básicas de diccionario}

  \InterfazFuncion{Vacío}{}{dicc($\sigma$)}
  {$res \igobs vacio$}
  [$\Theta(1)$]
  [genera un diccionario vacío.]

  \InterfazFuncion{Definir}{\Inout{d}{dicc($\sigma$)}, \In{k}{string}, \In{s}{$\sigma$}}{}
  [$d \igobs d_0$]
  {$d = definir(d, k, s)$}
  [$\Theta(long(k))$]
  [define la clave $k$ con el significado s en el diccionario.]
  [la clave se define por copia, pero el significado se define por referencia.]

  \InterfazFuncion{Definido?}{\In{d}{dicc($\sigma$)}, \In{k}{string}}{bool}
  [long(k) $>$ 0]
  {$res \igobs def?(d,k)$}
  [$\Theta(long(k))$]
  [devuelve true si k esta definido en el diccionario.]

  \InterfazFuncion{Significado}{\In{d}{dicc($\sigma$)}, \In{k}{string}}{$\sigma$}
  [$def?(d,k)$]
  {$res \igobs obtener(k,d)$}
  [$\Theta(long(k))$]
  [devuelve la referencia al significado de la clave k en d.]

\end{Interfaz}

\begin{Representacion}
  
  \Titulo{Representación del diccionario}

  \begin{Estructura}{dicc$(\sigma)$}[puntero(nodo)]
    \begin{Tupla}[nodo]
      \tupItem{caracteres}{ad(puntero(nodo))}%
      \tupItem{significado}{puntero($\sigma$)}%
    \end{Tupla}

  \end{Estructura}

  \RepFc[estr][d]{tam(d\DRef caracteres) = 256 $\yluego$ \\ ($\forall i$: nat) (n $\in$ [1..256] $\land$ d\DRef caracteres[n-1] $\neq$ NULL) $\impluego$ Rep(d\DRef caracteres[n-1])}\mbox{}

  \Abs[estr]{dicc($\sigma$)}[d]{dic}{
  ($\forall s$: string) def?(dic, s) = estaDefinido?(s, d) $\land$ \\ (def?(dic, s) \impluego ($\forall k$: string) obtener(k, dic) = dameSignificado(s, d))
  }

  ~

  \tadOperacion{dameSignificado}{string/s, puntero(nodo)/d}{bool}{}
  \tadAxioma{dameSignificado(s, d)}{
  
  \LIF{ d = NULL } \LTHEN{ NULL} \LELSE{ \\
    \LIF{ long(s) = 0} \LTHEN{ d\DRef significado }\\
    \LELSE{ dameSignificado(fin(s), d\DRef caracteres[ord(prim(s))-1])} \LFI
     } \\ \LFI
  }

  \tadOperacion{estaDefinido?}{string/s, puntero(nodo)/p}{bool}{}
  \tadAxioma{estaDefinido?(s, p)}{dameSignificado(s, p) $\neq$ NULL}

\end{Representacion}

\newpage

\begin{Algoritmos}

\TipoFuncion{iVacio}{}{dicc($\sigma$)} \\
\indent res $\leftarrow$ <caracteres: arreglo[256] de puntero(nodo), significado: puntero($\sigma$)>

~

\TipoFuncion{nuevoNodo}{}{nodo} \\
\indent res $\leftarrow$ <ad(puntero(nodo)), puntero($\sigma$)> 
%\indent $tupla.campo_1$ = arreglo[256] de puntero(nodo) \\
%\indent $tupla.campo_2$ = new $\sigma$ 

~

\TipoFuncion{iDefinir}{\Inout{d}{dicc($\sigma$)}, \In{k}{string}, \In{s}{$\sigma$}}{} \\
\indent var nodoActual $\leftarrow$ d \\
\indent var i $\leftarrow$ 0 \\
\indent while i $<$ long(k) \{ \\
\indent \indent if *nodoActual.campo$_1$[ord(k[i])] == NULL \\
\indent \indent \indent *nodoActual.campo$_1$[ord(k[i])] $\leftarrow$ nuevoNodo() \\
\indent \indent \} \\
\indent \indent nodoActual $\leftarrow$ *nodoActual.campo$_1$[ord(k[i])] \\
\indent \indent i++ \\
\indent \} \\
\indent *nodoActual.campo$_2$ $\leftarrow$ \&s

~

\TipoFuncion{iDefinido?}{\In{d}{dicc($\sigma$)}, \In{k}{string}}{bool} \\
\indent var nodoActual $\leftarrow$ d \\
\indent var i $\leftarrow$ 0 \\
\indent var seguirBuscando $\leftarrow$ true \\
\indent while i $<$ long(k) \&\& seguirBuscando \{ \\
\indent \indent if *nodoActual.campo$_1$[ord(k[i])] == NULL \{ \\
\indent \indent \indent seguirBuscando $\leftarrow$ false \\
\indent \indent \} else \{ \\
\indent \indent \indent nodoActual $\leftarrow$ *nodoActual.campo$_1$[ord(k[i])] \\
\indent \indent \indent i++ \\
\indent \indent \} \\
\indent \} \\
\indent res $\leftarrow$ false \\
\indent if i == long(k)  \{ \\
\indent \indent  res $\leftarrow$ (*nodoActual.campo$_2$[ord(k[i])] $\neq$ NULL) \\
\indent \} \\

~

\TipoFuncion{iSignificado}{\In{d}{dicc($\sigma$)}, \In{k}{string}}{$\sigma$} \\
\indent var nodoActual $\leftarrow$ d \\
\indent var i $\leftarrow$ 0 \\
\indent while i $<$ long(k) \{ \\
\indent \indent nodoActual $\leftarrow$ *nodoActual.campo$_1$[ord(k[i])] \\
\indent \indent i++ \\
\indent \} \\
\indent res $\leftarrow$ *nodoActual.campo$_2$

\end{Algoritmos}

\end{document}
